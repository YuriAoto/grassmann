"""Parser to dGr

Functions:
----------

parse_cmd_line
"""
import os
import sys
import re
import argparse
import textwrap
import logging
from collections import namedtuple

from dGr_exceptions import *

loglevels = {'critical': logging.CRITICAL,
             'error': logging.ERROR,
             'warning': logging.WARNING,
             'info': logging.INFO,
             'debug': logging.DEBUG,
             'notset': logging.NOTSET}

def __is_molpro_xml_file(file):
    """Return True if file is a Molpro xml file."""
    with open(file, 'r') as f:
        for l in f:
            if '<molpro xmlns="http://www.molpro.net/schema/molpro-output"' in l:
                return True
    return False

def __is_molpro_output(file):
    """Return True if file is a Molpro output."""
    with open(file, 'r') as f:
        for l in f:
            if '***  PROGRAM SYSTEM MOLPRO  ***' in l:
                return True
    return False

def __assert_molpro_output(file,
                           can_be_xml=False):
    """Raise dGrParseError if file does not exist or is not Molpro file."""
    if not os.path.isfile(file):
        raise dGrParseError('File ' + file + ' not found!')
    if not __is_molpro_output(file):
        if can_be_xml:
            if not __is_molpro_xml_file(file):
                raise dGrParseError('File ' + file + ' is not a Molpro output!')
        else:
            raise dGrParseError('File ' + file + ' is not a Molpro output!')

def parse_cmd_line():
    """Parse the command line for dGr, checking if it is all OK.
    
    Returns:
    --------
    An instance of argparse.Namespace, holding the command line arguments
    and some other string attributes:
    basename      the basename of the main Molpro file
    wdir          the working directory
    command       the execution command
    """
    parser = argparse.ArgumentParser(
        description='Optimise the distance to the Grassmannian, obtaining |min D>.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(textwrap.dedent('''\
        dGr read orbitals from Molpro\'s "put" xml files, that can be
        generated by adding the following line in the Molpro input:
        
        {put,xml,<file_name>; nosort; novariables}
        
        <file_name> is the name of the file that Molpro generates,
        and it is what is passed to dGr after --ini_orb, for example.
        ''')))
    parser.add_argument('molpro_output',
                        help='Molpro output with the correlated wave function')
    parser.add_argument('--ini_orb',
                        help='initial guess for orbitals or transformation matrices, '
                        + 'as Molpro\'s "put" xml file or basename of npz file '
                        + '(<INI_ORB>_U.npz)')
    parser.add_argument('--HF_orb',
                        help='Hartree-Fock orbitals (as Molpro\'s "put" xml file)')
    parser.add_argument('--WF_orb',
                        help='orbital basis of the wave function (as Molpro\'s'
                        + ' "put" xml file) If not given, assume to be the same as'
                        + ' molpro_output')
    parser.add_argument('--WF_templ',
                        help='a Molpro output with a Full CI wave function,'
                        + ' to be used as template')
    parser.add_argument('--state',
                        help='desired state, in Molpro notation')
    parser.add_argument('-l', '--loglevel',
                        help='set log level (integer)')
    parser.add_argument('--logfilter',
                        help='regular expression to filter function names'
                        +' for logging (for debug)')
    parser.add_argument('--use_general_algorithm',
                        help='use the general Absil algorithm for a general'
                        +' wave function',
                        action='store_true')
    parser.add_argument('--check_algorithms',
                        help='check if matrices C and X calculated'
                        +' with the CISD-opt and general algorithms are'
                        +' equivalent',
                        action='store_true')
    cmd_args = parser.parse_args()
    file_name = cmd_args.molpro_output
    cmd_args.basename = re.sub('\.out$', '', cmd_args.molpro_output)
    cmd_args.wdir = os.getcwd()
    cmd_args.command = ' '.join(sys.argv)
    __assert_molpro_output(cmd_args.molpro_output)
    if cmd_args.ini_orb is not None:
        try:
            __assert_molpro_output(cmd_args.ini_orb, can_be_xml=True)
        except dGrParseError as e:
            if 'File ' + cmd_args.ini_orb + ' not found' in str(e):
                if not os.path.isfile(cmd_args.ini_orb + '_U.npz'):
                    raise dGrParseError('Neither ' + cmd_args.ini_orb
                                        + ' nor ' + cmd_args.ini_orb
                                        + '_U.npz exist!')
                cmd_args.ini_orb = cmd_args.ini_orb + '_U.npz'
            else:
                raise e
    if cmd_args.check_algorithms and cmd_args.use_general_algorithm:
        raise dGrParseError('Options --check_algorithms and --use_general_algorithm'
                            + ' are incompatible: with --check_algorithms both'
                            + ' algorithms will be use in one iteration.')
    if cmd_args.check_algorithms and cmd_args.WF_templ is not None:
        raise dGrParseError('Options --check_algorithms and --WF_templ'
                            + ' are incompatible: --check_algorithms'
                            + ' is only for Absil algorithm.')
    if cmd_args.WF_orb is None:
        cmd_args.WF_orb = cmd_args.molpro_output
    else:
        __assert_molpro_output(cmd_args.WF_orb, can_be_xml=True)
    if cmd_args.HF_orb is None:
        cmd_args.HF_orb = cmd_args.WF_orb
    else:
        __assert_molpro_output(cmd_args.HF_orb, can_be_xml=True)
    if cmd_args.WF_templ is not None:
        __assert_molpro_output(cmd_args.WF_templ)
    if cmd_args.logfilter is not None:
        cmd_args.logfilter = re.compile(cmd_args.logfilter)
    cmd_args.state = cmd_args.state if cmd_args.state is not None else ''
    if cmd_args.loglevel is not None:
        try:
            cmd_args.loglevel = int(cmd_args.loglevel)
        except ValueError:
            try:
                cmd_args.loglevel = loglevels[cmd_args.loglevel.lower()]
            except KeyError:
                raise dGrParseError('This is not a valid log level: '+ cmd_args.loglevel)
    else:
        cmd_args.loglevel = logging.WARNING
    return cmd_args
