#!/usr/bin/env python3
"""Optimise the distance to the Grassmannian

Try `dGr --help` for the usage.

Yuri Aoto, 2018, 2019
"""
import os
import sys
import logging
import traceback

import dGr_parser
from dGr_main import dGr_main
from dGr_exceptions import dGrParseError, dGrError

assert sys.version_info >= (3, 5)
try:
    cmd_line_args = dGr_parser.parse_cmd_line()
except dGrParseError as e:
    sys.exit(str(e))

name_extra = cmd_line_args.state
if name_extra:
    name_extra = '_' + name_extra
output_name = cmd_line_args.basename + '.min_dist' + name_extra
logfile_name = output_name + '.log'

if os.path.exists(output_name) or os.path.exists(logfile_name):
    i_backup = '_0'
    while (os.path.exists(output_name + i_backup)
           or os.path.exists(logfile_name + i_backup)):
        i_backup = '_' + str(int(i_backup[1:]) + 1)
    try:
        os.rename(output_name, output_name + i_backup)
    except FileNotFoundError:
        pass
    try:
        os.rename(output_name + '_U.npz', output_name + '_U.npz' + i_backup)
    except FileNotFoundError:
        pass
    try:
        os.rename(logfile_name, logfile_name + i_backup)
    except FileNotFoundError:
        pass

log_format = ('%(levelname)s: %(funcName)s - %(filename)s:'
              + '\n%(message)s\n')
logging.basicConfig(filename=logfile_name,
                    format=log_format,
                    filemode='w',
                    level=cmd_line_args.loglevel)
logger = logging.getLogger(__name__)


class myLogFilter():
    """Define a filter for logging, to be attached to all handlers."""
    def filter(self, rec):
        """Return a boolean, indicating whether rec will be logged or not."""
        if rec.funcName == '__enter__':
            rec.funcName = 'Entering time management'
        elif rec.funcName == '__exit__':
            rec.funcName = 'Finishing time management'
        if cmd_line_args.logfilter is not None:
            return not cmd_line_args.logfilter.search(rec.funcName) is None
        # Uncomment this to check for possible records to filter
        # print()
        # print(rec)
        # print(rec.__dict__)
        # print()
        return True


for handler in logging.root.handlers:
    handler.addFilter(myLogFilter())
f_out = None
with_error = False
try:
    f_out = open(output_name, 'w')
    dGr_main(cmd_line_args, f_out)
except dGrError as e:
    with_error = True
    error_msg = ('dGrError: ' + str(e)
                 + '\nHere is the traceback:\n' + traceback.format_exc())
except Exception:
    with_error = True
    error_msg = 'Unknown error:\n' + traceback.format_exc()
finally:
    if with_error and f_out is not None:
        f_out.write('\n' + error_msg)
    if f_out is not None:
        f_out.close()
    if with_error:
        sys.exit(error_msg)
exit()
