"""Parse the command line and inputs to Grassmann


The main function of this module, parse, returns a namespace
with all information coming from the command line and from the input files.
Most of them are assessed with the attribute with the same name as
used by the user to pass the information. For instance, after using

    Grassmann --geometry h2o.xyz --basis cc-pVDZ

one assess these information with:

    args = parser.parse()
    args.geometry  # h2o.xyz
    args.basis     # cc-pVDZ

etc. Some extra analysis is made and extra attributes are added.
Some are:

sys_argv (list of str)
    The original sys.argv (That is modified by this module

files_content (list of str)
    The names and content of all files used as input:


"""
import os
import sys
import re
import argparse
import textwrap
import logging

_loglevels = {'critical': logging.CRITICAL,
              'error': logging.ERROR,
              'warning': logging.WARNING,
              'info': logging.INFO,
              'debug': logging.DEBUG,
              'notset': logging.NOTSET}


class ParseError(Exception):
    pass


def _parser():
    parser = argparse.ArgumentParser(
        description=(
            'Grassmann.\n'
            +'Exploring the geometry of the electronic wave functions space'),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(textwrap.dedent('''\
        Grassmann reads orbitals from Molpro\'s "put" xml files, that can be
        generated by adding the following line in the Molpro input:
        
        {put,xml,<file_name>; nosort; novariables}
        
        <file_name> is the name of the file that Molpro generates,
        and it is what is passed to Grassmann after --ini_orb, for example.
        ''')))
    parser.add_argument('--molpro_output',
                        help='Molpro output with the correlated wave function')
    parser.add_argument('--geometry',
                        help='A xyz geometry file')
    parser.add_argument('--memory', default='100.0kB',
                        help='memory')
    parser.add_argument('--basis', default='cc-pVDZ',
                        help='basis set')
    parser.add_argument('--ini_orb',
                        help='initial guess for orbitals'
                        + ' or transformation matrices,'
                        + ' as Molpro\'s "put" xml file or'
                        + ' npz file')
    parser.add_argument('--HF_orb',
                        help='Hartree-Fock orbitals'
                        + ' (as Molpro\'s "put" xml file)')
    parser.add_argument('--restricted',
                        help='Restricted calculation.',
                        action='store_true')
    parser.add_argument('--ms2',
                        help='The MS of Hartree-Fock calculation.',
                        type=int)
    parser.add_argument('--method',
                        help='The method.')
    parser.add_argument('--WF_orb',
                        help='orbital basis of the wave function'
                        + ' (as Molpro\'s "put" xml file).'
                        + ' If not given, assume  to be the same as'
                        + '  molpro_output')
    parser.add_argument('--WF_templ',
                        help='a Molpro output with a Full CI wave function,'
                        + ' to be used as template')
    parser.add_argument('--maxiter',
                        help='Maximum number of iterations',
                        type=int)
    parser.add_argument('--at_ref',
                        help='Do only one iteration at reference.',
                        action='store_true')
    parser.add_argument('--algorithm',
                        help='the algorithm to be used in the optimisation.'
                        + ' Possible values are: "orb_rotations",'
                        + ' "general_Absil",  and "CISD_Absil".'
                        + ' Default is "CISD_Absil".')
    parser.add_argument('--save_final_orb',
                        help='If set, save final orbitals.',
                        action='store_true')
    parser.add_argument('--save_full_orb',
                        help='If set, the saved orbitals will contain'
                        + ' also the virtual orbitals of the optimised'
                        + ' point.',
                        action='store_true')
    parser.add_argument('--save_all_orb',
                        help='If set, the orbitals are saved in every'
                        + ' iteration of the optimisation, in the files'
                        + 'orb_it_<i_it>.npz',
                        action='store_true')
    parser.add_argument('--state',
                        help='desired state, in Molpro notation')
    parser.add_argument('-l', '--loglevel',
                        help='set log level (integer)')
    parser.add_argument('--logfilter',
                        help='regular expression to filter function names'
                        + ' for logging (for debug)')
    parser.add_argument('--out_extension',
                        help='The extension for output file',
                        default='.gr')
    parser.add_argument('--log_extension',
                        help='The extension for the log file',
                        default='.grlog')
    parser.add_argument('--dir_extension',
                        help='The extension for directory with extra files',
                        default='.grdir')
    parser.add_argument('--output',
                        help='Output file name. Passing this option overwrites'
                        + '--out_extension.')
    return parser


def _is_molpro_xml_file(file):
    """Return True if file is a Molpro xml file."""
    with open(file, 'r') as f:
        for line in f:
            if ('<molpro xmlns="http://www.molpro.net/schema/molpro-output"'
                    in line):
                return True
    return False


def _is_molpro_output(file):
    """Return True if file is a Molpro output."""
    with open(file, 'r') as f:
        for line in f:
            if '***  PROGRAM SYSTEM MOLPRO  ***' in line:
                return True
    return False


def _assert_molpro_output(file,
                          can_be_xml=False):
    """Raise ParseError if file does not exist or is not Molpro file."""
    if not os.path.isfile(file):
        raise ParseError('File ' + file + ' not found!')
    if not _is_molpro_output(file):
        if can_be_xml:
            if not _is_molpro_xml_file(file):
                raise ParseError('File ' + file
                                 + ' is not a Molpro output!')
        else:
            raise ParseError('File ' + file + ' is not a Molpro output!')


def _check(args):
    """Check if all arguments are OK and improve them, modifying args"""
    if args.output is not None:
        args.basename = args.output
    elif args.main_input is not None:
        args.basename = args.main_input
    elif args.geometry is not None:
        args.basename = re.sub(r'\.xyz$', '', args.geometry)
    elif args.molpro_output is not None:
        args.basename = re.sub(r'\.out$', '', args.molpro_output)
    else:
        args.basename = 'grassmann'
    args.output = args.basename + args.out_extension
    args.logfile = args.basename + args.log_extension
    args.outdir = args.basename + args.dir_extension
    args.wdir = os.getcwd()
    args.command = ''
    if args.algorithm is None:
        args.algorithm = 'CISD_Absil'
    elif args.algorithm not in ['orb_rotations',
                                'general_Absil',
                                'CISD_Absil']:
        raise ParseError('Unknown algorithm: ' + args.algorithm
                         + '. Possible values:\n'
                         + 'orb_rotations (default), '
                         + 'general_Absil, '
                         + 'and CISD_Absil')
    mem_re = re.match('([0-9]*\.?[0-9]*)_*([kMGT]?B)?$', args.memory)
    if mem_re:
        x, unit = mem_re.groups()
        try:
            x = float(x)
        except ValueError:
            raise ParseError(args.memory
                             + ' is not a valid memory specification')
        args.memory = (x, 'kB' if unit is None else unit)
    else:
        raise ParseError(args.memory
                         + ' is not a valid memory specification')
    if args.maxiter is None:
        args.maxiter = 20
    elif args.at_ref:
        raise ParseError('--maxiter is not compatible with --at_ref')
    if args.ini_orb is not None:
        if args.at_ref:
            raise ParseError('--ini_orb is not compatible with --at_ref')
        if (args.ini_orb[-4:] == '.npz'
                and os.path.isfile(args.ini_orb)):
            pass
        else:
            _assert_molpro_output(args.ini_orb, can_be_xml=True)
    if args.method is None:
        if args.geometry is None:
            args.method = 'dist_Grassmann'
        else:
            args.method = 'Hartree_Fock'
    if args.WF_orb is None:
        args.WF_orb = args.molpro_output
    else:
        _assert_molpro_output(args.WF_orb, can_be_xml=True)
    if args.HF_orb is None:
        args.HF_orb = args.WF_orb
    else:
        _assert_molpro_output(args.HF_orb, can_be_xml=True)
    if args.WF_templ is not None:
        _assert_molpro_output(args.WF_templ)
    if args.logfilter is not None:
        args.logfilter = re.compile(args.logfilter)
    args.state = args.state if args.state is not None else ''
    if args.loglevel is not None:
        try:
            args.loglevel = int(args.loglevel)
        except ValueError:
            try:
                args.loglevel = _loglevels[args.loglevel.lower()]
            except KeyError:
                raise ParseError('This is not a valid log level: '
                                 + args.loglevel)
    else:
        args.loglevel = logging.WARNING


def _argvise_file(filename, files_content, indentation):
    """Read file filename and return a list of strings similar to argv
    
    For a file with lines such as:
    
        <arg> = <value>
        <input>
    
    A list is returned, with all the pair '--<arg>' '<value>'.
    If a line with no '=' is found, this is assumed to be a filename,
    and this function is called recursivelly.
    This final list is supposed to be interpreted
    by the parse_cmd_line function, and all arguments merged in the same Namespace
    object.
    
    The spaces in the strings to the left of equal signs are changed to "_". 
    
    See parse_cmd_line function for more information.
    
    
    Parameters:
    -----------
    filename (str)
        The file name
    
    files_content (list of str)
        The content of all files so far argvised.
        This list is changed, as a side effect of this function
    
    indentation (str, spaces)
        This is used as indentation to store the contents of present file
    
    Return:
    -------
    A list of strings, similar to what one expects as command line arguments
    
    Side Effect:
    ------------
    List files_content is changed to add the conten of the present file.
    
    
    """
    args = []
    try:
        files_content.append(indentation + '# -------------------\n')
        files_content.append(indentation + '# ' + filename + ':\n')
        with open(filename, 'r') as f:
            for line in f:
                files_content.append(indentation + line)
                line_nocomment = line.split('#')[0].strip()
                if '=' in line_nocomment:
                    try:
                        k, v = line_nocomment.split('=')
                    except ValueError:
                        raise ParseError(
                            'Failed when reading line at ' + filename + ':\n'
                            + line)
                    args.append('--' + k.strip().replace(' ', '_'))
                    args.append(v.strip().replace(' ', '_'))
                elif line_nocomment:
                    if ' ' in line_nocomment:
                        args.append('--' + line_nocomment.replace(' ', '_'))
                    else:
                        args.extend(_argvise_file(line_nocomment,
                                                  files_content,
                                                  indentation + '  '))
        files_content.append(indentation + '# END of ' + filename + '\n')
        files_content.append(indentation + '# -------------------\n')
    except FileNotFoundError:
        raise ParseError('No such file: ' + filename)
    return args


def _parse_files_in_sys_argv(sysargv=None):
    """Changes sysargv to include "argvised" files
    
    To each element of sysargv that is for not a pair
    --key value, say filename, change it by the content
    of the file with that name, after applying _argvise_file
    on it.
    
    Parameters:
    -----------
    sysargv (list of str or None)
        Is None, use sys.argv. Otherwise use this to extract the arguments
    
    Return:
    -------
    The tuple with the following:
    
    orig_sysargv (list of str)
        The original sysargv
    
    files_content (list of str)
        The content of all files
        (line by line, with indented included files)
    
    main_input (None or str)
        The file name of main input
    
    Side Effect:
    ------------
    The sysargv is changed
    """
    sysargv = sys.argv if sysargv is None else sysargv
    files_content = []
    orig_sysargv = sysargv[:]
    main_input = None
    i = 1
    while i < len(sysargv):
        if sysargv[i][:2] != '--' and sysargv[i-1][:2] != '--':
            if main_input is None:
                main_input = sysargv[i]
            argvfile = _argvise_file(sysargv[i], files_content, '')
            sysargv[i:i] = argvfile
            i += len(argvfile)
            del sysargv[i]
        else:
            i += 2
    return orig_sysargv, files_content, main_input


def parse(sysargv=None):
    """Parse the command line and possible input files
    
    Parameters:
    -----------
    sysargv (list of str or None)
        Is None, use sys.argv. Otherwise use this to extrac the arguments
    
    Return:
    --------
    An instance of argparse.Namespace, holding all the arguments
    and some other attributes, see module docstring
    """
    orig_sysargv, files_content, main_input = _parse_files_in_sys_argv(sysargv)
    args = _parser().parse_args(sysargv)
    args.sys_argv = orig_sysargv
    args.files_content = files_content
    args.main_input = main_input
    _check(args)
    return args
